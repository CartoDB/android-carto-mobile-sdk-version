/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.11
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.carto.graphics;

import com.carto.core.BinaryData;

/**
 * A class that provides the functionality to store, compress, uncompress and resize basic image formats.<br>
 * Currently supported formats are png and jpeg. Upon loading compressed images will be converted to<br>
 * alpha premultiplied uncompressed bitmaps of various image formats.
 */
public class Bitmap {
  /** @hidden */
  private transient long swigCPtr;
  /** @hidden */
  protected transient boolean swigCMemOwn;

  /** @hidden */
  public Bitmap(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  /** @hidden */
  public static long getCPtr(Bitmap obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  /** @hidden */
  protected void finalize() {
    delete();
  }

  /** @hidden */
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        BitmapModuleJNI.delete_Bitmap(swigCPtr);
      }
      swigCPtr = 0;
    }
  }


  /**
   * Checks if this object is equal to the specified object.
   * @param obj The reference object.
   * @return True when objects are equal, false otherwise.
   */
  public boolean equals(Object obj) {
    if (obj instanceof Bitmap) {
      return ((Bitmap)obj).swigGetRawPtr() == swigGetRawPtr();
    }
    return false;
  }

  /**
   * Returns the hash value of this object.
   * @return The hash value of this object.
   */
  public int hashCode() {
    return (int)swigGetRawPtr();
  }


/**
 * Constructs a bitmap from an already decoded vector of bytes. The bitmap data is expected to be alpha premultiplied, if alpha channel is used.<br>
 * If the power of two conversion flag is set, additional padding will be added to the image to make it's dimensions power of two.<br>
 * This can be useful when creating OpenGL textures from the Bitmap, because some GPUs perform badly with non power of two textures.<br>
 * @param pixelData A vector of decoded, premultiplied bitmap bytes.<br>
 * @param width The width of the bitmap.<br>
 * @param height The height of the bitmap.<br>
 * @param colorFormat The color format of the bitmap.<br>
 * @param bytesPerRow The total number of bytes per row. Some bitmaps have additional padding at the end of each row. If the value is negative, then bitmap is assumed to be vertically flipped. In this case absolute value of the bytesPerRow value is used.
 */
  public Bitmap(BinaryData pixelData, long width, long height, ColorFormat colorFormat, int bytesPerRow) {
    this(BitmapModuleJNI.new_Bitmap(BinaryData.getCPtr(pixelData), pixelData, width, height, colorFormat.swigValue(), bytesPerRow), true);
  }

/**
 * Returns the width of the bitmap.<br>
 * @return The width of the bitmap.
 */
  public long getWidth() {
    return BitmapModuleJNI.Bitmap_getWidth(swigCPtr, this);
  }

/**
 * Returns the height of the bitmap.<br>
 * @return The height of the bitmap.
 */
  public long getHeight() {
    return BitmapModuleJNI.Bitmap_getHeight(swigCPtr, this);
  }

/**
 * Returns the color format of this bitmap.<br>
 * @return The color format of this bitmap.
 */
  public ColorFormat getColorFormat() {
    return ColorFormat.swigToEnum(BitmapModuleJNI.Bitmap_getColorFormat(swigCPtr, this));
  }

/**
 * Returns the bytes per pixel parameter of this bitmap. Valid values are 1, 2, 3 and 4.<br>
 * @return The bytes per pixel parameter of this bitmap.
 */
  public long getBytesPerPixel() {
    return BitmapModuleJNI.Bitmap_getBytesPerPixel(swigCPtr, this);
  }

/**
 * Returns a copy of the pixel data of this bitmap.<br>
 * @return A binary data of the bitmap's pixel data.
 */
  public BinaryData getPixelData() {
    long cPtr = BitmapModuleJNI.Bitmap_getPixelData(swigCPtr, this);
    return (cPtr == 0) ? null : new BinaryData(cPtr, true);
  }

/**
 * Compresses this bitmap to a PNG format.<br>
 * @return A byte vector of the PNG's data.
 */
  public BinaryData compressToPNG() {
    long cPtr = BitmapModuleJNI.Bitmap_compressToPNG(swigCPtr, this);
    return (cPtr == 0) ? null : new BinaryData(cPtr, true);
  }

/**
 * Compresses this bitmap to a internal format.<br>
 * This operation is intended for serialization of the data only, no actual compression is performed.<br>
 * @return A byte vector of the serialized data.
 */
  public BinaryData compressToInternal() {
    long cPtr = BitmapModuleJNI.Bitmap_compressToInternal(swigCPtr, this);
    return (cPtr == 0) ? null : new BinaryData(cPtr, true);
  }

/**
 * Returns resized version of the bitmap. The power of two padding added during the construction of this bitmap<br>
 * will be removed prior to resizing. If the power of two conversion flag is set, new padding will be added to the image <br>
 * after resizing to make it's dimensions power of two.<br>
 * @param width The new width of this bitmap.<br>
 * @param height The new height of this bitmap.<br>
 * @return The resized bitmap instance or null in case of error (wrong dimensions).
 */
  public Bitmap getResizedBitmap(long width, long height) {
    long cPtr = BitmapModuleJNI.Bitmap_getResizedBitmap(swigCPtr, this, width, height);
    return (cPtr == 0) ? null : new Bitmap(cPtr, true);
  }

/**
 * Returns sub-bitmap with specified offsets and dimensions.<br>
 * @param xOffset X coordinate offset in the bitmap.<br>
 * @param yOffset Y coordinate offset in the bitmap.<br>
 * @param width Width of the sub-bitmap.<br>
 * @param height Height of the sub-bitmap.<br>
 * @return Sub-bitmap instance or null in case of error (wrong dimensions).
 */
  public Bitmap getSubBitmap(int xOffset, int yOffset, int width, int height) {
    long cPtr = BitmapModuleJNI.Bitmap_getSubBitmap(swigCPtr, this, xOffset, yOffset, width, height);
    return (cPtr == 0) ? null : new Bitmap(cPtr, true);
  }

/**
 * Returns paddedsub-bitmap with specified offsets and dimensions.<br>
 * @param xPadding Padding along X coordinate. If negative value is used, the bitmap is padded from the left. By default, bitmap is padded from the right.<br>
 * @param yPadding Padding along Y coordinate. If negative value is used, the bitmap is padded from the top. By default, bitmap is padded from the bottom.<br>
 * @return Padded bitmap instance or null in case of error (wrong dimensions).
 */
  public Bitmap getPaddedBitmap(int xPadding, int yPadding) {
    long cPtr = BitmapModuleJNI.Bitmap_getPaddedBitmap(swigCPtr, this, xPadding, yPadding);
    return (cPtr == 0) ? null : new Bitmap(cPtr, true);
  }

/**
 * Returns copy of the bitmap converted to RGBA format.<br>
 * @return The bitmap with identical dimensions but converted to RGBA format.
 */
  public Bitmap getRGBABitmap() {
    long cPtr = BitmapModuleJNI.Bitmap_getRGBABitmap(swigCPtr, this);
    return (cPtr == 0) ? null : new Bitmap(cPtr, true);
  }

/**
 * Creates a new bitmap from compressed byte vector.<br>
 * If the power of two conversion flag is set, additional padding will be added to the image to make it's dimensions power of two.<br>
 * @param compressedData The compressed bitmap data.<br>
 * @return The bitmap created from the compressed data. If the decompression fails, null is returned.
 */
  public static Bitmap createFromCompressed(BinaryData compressedData) {
    long cPtr = BitmapModuleJNI.Bitmap_createFromCompressed(BinaryData.getCPtr(compressedData), compressedData);
    return (cPtr == 0) ? null : new Bitmap(cPtr, true);
  }

/**
 * Returns the raw pointer to the object. This is used internally by the SDK.<br>
 * @return The internal pointer of the object.
 */
  /** @hidden */
  public long swigGetRawPtr() {
    return BitmapModuleJNI.Bitmap_swigGetRawPtr(swigCPtr, this);
  }

}
