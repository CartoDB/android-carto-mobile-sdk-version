/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.11
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.carto.components;

import com.carto.core.MapBounds;
import com.carto.core.MapRange;
import com.carto.core.MapVec;
import com.carto.core.ScreenPos;
import com.carto.graphics.Bitmap;
import com.carto.graphics.Color;
import com.carto.projections.Projection;

/**
 * A class containing various options for rendering and map manipulation.
 */
public class Options {
  /** @hidden */
  private transient long swigCPtr;
  /** @hidden */
  protected transient boolean swigCMemOwn;

  /** @hidden */
  public Options(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  /** @hidden */
  public static long getCPtr(Options obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  /** @hidden */
  protected void finalize() {
    delete();
  }

  /** @hidden */
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OptionsModuleJNI.delete_Options(swigCPtr);
      }
      swigCPtr = 0;
    }
  }


  /**
   * Checks if this object is equal to the specified object.
   * @param obj The reference object.
   * @return True when objects are equal, false otherwise.
   */
  public boolean equals(Object obj) {
    if (obj instanceof Options) {
      return ((Options)obj).swigGetRawPtr() == swigGetRawPtr();
    }
    return false;
  }

  /**
   * Returns the hash value of this object.
   * @return The hash value of this object.
   */
  public int hashCode() {
    return (int)swigGetRawPtr();
  }


/**
 * Returns the color of the ambient light.<br>
 * @return The color of the ambient light.
 */
  public Color getAmbientLightColor() { return new Color(OptionsModuleJNI.Options_getAmbientLightColor(swigCPtr, this), true); }

/**
 * Sets the ambient light color.<br>
 * Ambient light affects all lighting enabled models in the scene equally, it has no direction or location.<br>
 * @param color The new color for the ambient light.
 */
  public void setAmbientLightColor(Color color) {
    OptionsModuleJNI.Options_setAmbientLightColor(swigCPtr, this, Color.getCPtr(color), color);
  }

/**
 * Returns the color of the main light.<br>
 * @return The color of the main light.
 */
  public Color getMainLightColor() { return new Color(OptionsModuleJNI.Options_getMainLightColor(swigCPtr, this), true); }

/**
 * Sets the color of the main light. The main light affects all lighting enabled models<br>
 * in the scene equally from a certain direction. This light can be used to simulate sun or moon light.<br>
 * @param color The new color for the main light.
 */
  public void setMainLightColor(Color color) {
    OptionsModuleJNI.Options_setMainLightColor(swigCPtr, this, Color.getCPtr(color), color);
  }

/**
 * Returns the direction of the main light.<br>
 * @return The direction of the main light.
 */
  public MapVec getMainLightDirection() { return new MapVec(OptionsModuleJNI.Options_getMainLightDirection(swigCPtr, this), true); }

/**
 * Sets the direction of the main light. The main light affects all lighting enabled models<br>
 * in the scene equally from a certain direction. This light can be used to simulate sun or moon light.<br>
 * The direction is always measured based on the local tangent frame of the focus point. <br>
 * @param direction The new direction vector for the main light. (0,0,-1) means straight down, (-0.707,0,-0.707) means<br>
 *        from east with a 45 degree angle. The direction vector will be normalized.
 */
  public void setMainLightDirection(MapVec direction) {
    OptionsModuleJNI.Options_setMainLightDirection(swigCPtr, this, MapVec.getCPtr(direction), direction);
  }

/**
 * Returns the render projection mode.<br>
 * @return The render projection mode.
 */
  public RenderProjectionMode getRenderProjectionMode() {
    return RenderProjectionMode.swigToEnum(OptionsModuleJNI.Options_getRenderProjectionMode(swigCPtr, this));
  }

/**
 * Sets the render projection mode. The default is RenderProjectionMode::PLANAR.<br>
 * @param renderProjectionMode The new render projection mode.
 */
  public void setRenderProjectionMode(RenderProjectionMode renderProjectionMode) {
    OptionsModuleJNI.Options_setRenderProjectionMode(swigCPtr, this, renderProjectionMode.swigValue());
  }

/**
 * Returns the click type detection state.<br>
 * @return True if click type detection is enabled.
 */
  public boolean isClickTypeDetection() {
    return OptionsModuleJNI.Options_isClickTypeDetection(swigCPtr, this);
  }

/**
 * Sets the state of the click type detection flag. If set to true clicks are categorized as normal clicks, double clicks,<br>
 * long clicks and dual clicks. The default is true.<br>
 * @param enabled The new state of the click type detection flag.
 */
  public void setClickTypeDetection(boolean enabled) {
    OptionsModuleJNI.Options_setClickTypeDetection(swigCPtr, this, enabled);
  }

/**
 * Returns the double click detection state.<br>
 * @return True if double click detection is enabled.
 */
  public boolean isDoubleClickDetection() {
    return OptionsModuleJNI.Options_isDoubleClickDetection(swigCPtr, this);
  }

/**
 * Sets the state of the double click detection flag. If set to true clicks, then double clicks are detected separately from normal clicks. are categorized as normal clicks, double clicks,<br>
 * The click type resolving takes about 400ms (configurable via setDoubleClickMaxDuration), so for applications that do not <br>
 * require this functionality, it can be turned off. The default is true.<br>
 * @param enabled The new state of the double click detection flag.
 */
  public void setDoubleClickDetection(boolean enabled) {
    OptionsModuleJNI.Options_setDoubleClickDetection(swigCPtr, this, enabled);
  }

/**
 * Returns the long click duration in seconds.<br>
 * @return The long click duration in seconds.
 */
  public float getLongClickDuration() {
    return OptionsModuleJNI.Options_getLongClickDuration(swigCPtr, this);
  }

/**
 * Sets the long click duration in seconds. The default is value is 0.4 (400ms).<br>
 * @param duration The new duration for the long click in seconds.
 */
  public void setLongClickDuration(float duration) {
    OptionsModuleJNI.Options_setLongClickDuration(swigCPtr, this, duration);
  }

/**
 * Returns the double click max duration in seconds.<br>
 * @return The double click max duration in seconds.
 */
  public float getDoubleClickMaxDuration() {
    return OptionsModuleJNI.Options_getDoubleClickMaxDuration(swigCPtr, this);
  }

/**
 * Sets the double click max in seconds. The default is value is 0.4 (400ms).<br>
 * @param duration The new value for the double click max duration detection in seconds.
 */
  public void setDoubleClickMaxDuration(float duration) {
    OptionsModuleJNI.Options_setDoubleClickMaxDuration(swigCPtr, this, duration);
  }

/**
 * Returns the tile size used for drawing map tiles.<br>
 * @return The tile size in density-independent pixels (dp).
 */
  public int getTileDrawSize() {
    return OptionsModuleJNI.Options_getTileDrawSize(swigCPtr, this);
  }

/**
 * Sets the tile size for drawing map tiles. Different datasources may have different tile sizes, this option<br>
 * can be used to compensate for bigger or smaller tiles than default. The default is 256.<br>
 * @param tileDrawSize The new tile size in density-independent pixels (dp).
 */
  public void setTileDrawSize(int tileDrawSize) {
    OptionsModuleJNI.Options_setTileDrawSize(swigCPtr, this, tileDrawSize);
  }

/**
 * Returns the dots per inch value.<br>
 * @return The dots per inch value.
 */
  public float getDPI() {
    return OptionsModuleJNI.Options_getDPI(swigCPtr, this);
  }

/**
 * Sets the dots per inch value. This is calculated automatically by the SDK when the MapView is created using <br>
 * the device screen parameters. The purpose of this value is to compensate for very high or low resolution devices,<br>
 * so that the map remains readable.<br>
 * @param dpi The new dots per inch value.
 */
  public void setDPI(float dpi) {
    OptionsModuleJNI.Options_setDPI(swigCPtr, this, dpi);
  }

/**
 * Returns the draw distance value.<br>
 * @return The draw distance value.
 */
  public float getDrawDistance() {
    return OptionsModuleJNI.Options_getDrawDistance(swigCPtr, this);
  }

/**
 * Sets a new draw distance value. The higher the draw distance the more tiles can be seen, if the map is tilted.<br>
 * Changing the draw distance will cause the horizon to move, which means that the if the sky bitmap is used,<br>
 * the horizon may not match up anymore. Increasing this value will decrease performance and increase network traffic, <br>
 * if online map is used. The default is 16.<br>
 * @param drawDistance The new draw distance value.
 */
  public void setDrawDistance(float drawDistance) {
    OptionsModuleJNI.Options_setDrawDistance(swigCPtr, this, drawDistance);
  }

/**
 * Returns the vertial field of view angle.<br>
 * @return The vertical field of view angle in degrees.
 */
  public int getFieldOfViewY() {
    return OptionsModuleJNI.Options_getFieldOfViewY(swigCPtr, this);
  }

/**
 * Sets the vertial field of view angle. Larger values increase the viewable area, at the cost of performance and<br>
 * additional perspective distortion. The default is 70.<br>
 * @param fovY The new vertical field of view angle in degrees.
 */
  public void setFieldOfViewY(int fovY) {
    OptionsModuleJNI.Options_setFieldOfViewY(swigCPtr, this, fovY);
  }

/**
 * Returns the panning mode.<br>
 * @return The panning mode.
 */
  public PanningMode getPanningMode() {
    return PanningMode.swigToEnum(OptionsModuleJNI.Options_getPanningMode(swigCPtr, this));
  }

/**
 * Sets the panning mode. The default is PanningMode::FREE.<br>
 * @param panningMode The new panning mode.
 */
  public void setPanningMode(PanningMode panningMode) {
    OptionsModuleJNI.Options_setPanningMode(swigCPtr, this, panningMode.swigValue());
  }

/**
 * Returns the pivot mode.<br>
 * @return The pivot mode.
 */
  public PivotMode getPivotMode() {
    return PivotMode.swigToEnum(OptionsModuleJNI.Options_getPivotMode(swigCPtr, this));
  }

/**
 * Sets the pivot mode. The default is PIVOT_MODE_TOUCHPOINT<br>
 * @param pivotMode The new pivot mode.
 */
  public void setPivotMode(PivotMode pivotMode) {
    OptionsModuleJNI.Options_setPivotMode(swigCPtr, this, pivotMode.swigValue());
  }

/**
 * Returns the state of seamless horizontal panning flag.<br>
 * @return True if seamless horizontal panning is enabled.
 */
  public boolean isSeamlessPanning() {
    return OptionsModuleJNI.Options_isSeamlessPanning(swigCPtr, this);
  }

/**
 * Sets the state of seamless horizontal panning flag. If set to true, the user can scroll seamlessly from<br>
 * the left side of the map to the right, and the other way around. The default is true.<br>
 * @param enabled The new state of seamless horizontal panning flag.
 */
  public void setSeamlessPanning(boolean enabled) {
    OptionsModuleJNI.Options_setSeamlessPanning(swigCPtr, this, enabled);
  }

/**
 * Returns the state of the restricted panning flag.<br>
 * @return True if restricted panning is enabled.
 */
  public boolean isRestrictedPanning() {
    return OptionsModuleJNI.Options_isRestrictedPanning(swigCPtr, this);
  }

/**
 * Sets the restricted panning flag. If set to true, then focus point coordinates and zoom level of the map view<br>
 * will be adjusted to display as little empty background as possible. The default is false.
 */
  public void setRestrictedPanning(boolean enabled) {
    OptionsModuleJNI.Options_setRestrictedPanning(swigCPtr, this, enabled);
  }

/**
 * Returns true if tilting gesture direction is reversed (and same as with Google Maps).<br>
 * @return True if tilting gesture direction is reversed (and same as with Google Maps). Otherwise returns false.
 */
  public boolean isTiltGestureReversed() {
    return OptionsModuleJNI.Options_isTiltGestureReversed(swigCPtr, this);
  }

/**
 * Sets the tilting gesture direction. By default, the gesture is not reversed.<br>
 * @param reversed True if Google Maps compatible mode should be used. False otherwise (default).
 */
  public void setTiltGestureReversed(boolean reversed) {
    OptionsModuleJNI.Options_setTiltGestureReversed(swigCPtr, this, reversed);
  }

/**
 * Returns the state of zoom gestures. <br>
 * @return True if zoom gestures are enabled. False otherwise.
 */
  public boolean isZoomGestures() {
    return OptionsModuleJNI.Options_isZoomGestures(swigCPtr, this);
  }

/**
 * Sets the zoom gestures flag. Zoom gestures allow to use double click and dual click to zoom in/out of the map.<br>
 * By default, zoom gestures are not enabled. Note that zoom gestures require that click detection mode is enabled and also that double click detection is enabled.<br>
 * @param enabled True if zoom gestured should be enabled, false otherwise.
 */
  public void setZoomGestures(boolean enabled) {
    OptionsModuleJNI.Options_setZoomGestures(swigCPtr, this, enabled);
  }

/**
 * Returns the number of threads used by the envelope task pool.<br>
 * @return The envelope task thread pool size.
 */
  public int getEnvelopeThreadPoolSize() {
    return OptionsModuleJNI.Options_getEnvelopeThreadPoolSize(swigCPtr, this);
  }

/**
 * Sets the number of threads used by the envelope task pool. More threads means more envelope tasks <br>
 * are executed in parallel. This might speed up the data query, but may cause performance drops. Default is 1.<br>
 * @param poolSize The new envelope task thread pool size.
 */
  public void setEnvelopeThreadPoolSize(int poolSize) {
    OptionsModuleJNI.Options_setEnvelopeThreadPoolSize(swigCPtr, this, poolSize);
  }

/**
 * Returns the number of threads used by the tile task pool.<br>
 * @return The tile task thread pool size.
 */
  public int getTileThreadPoolSize() {
    return OptionsModuleJNI.Options_getTileThreadPoolSize(swigCPtr, this);
  }

/**
 * Sets the number of threads used by the tile task pool. More threads means more tile tasks<br>
 * are executed in parallel. This might speed up the data query, but may cause performance drops. Default is 1.<br>
 * @param poolSize The new tile task thread pool size.
 */
  public void setTileThreadPoolSize(int poolSize) {
    OptionsModuleJNI.Options_setTileThreadPoolSize(swigCPtr, this, poolSize);
  }

/**
 * Returns the clear color used by the renderer before drawing anything else.<br>
 * By default, this is white. It should be set to (0, 0, 0, 0) if transparent MapView is needed.<br>
 * @return The clear color.
 */
  public Color getClearColor() { return new Color(OptionsModuleJNI.Options_getClearColor(swigCPtr, this), true); }

/**
 * Sets the clear color of the renderer.<br>
 * @param color The new clear color.
 */
  public void setClearColor(Color color) {
    OptionsModuleJNI.Options_setClearColor(swigCPtr, this, Color.getCPtr(color), color);
  }

/**
 * Returns the sky color.<br>
 * @return The sky color.
 */
  public Color getSkyColor() { return new Color(OptionsModuleJNI.Options_getSkyColor(swigCPtr, this), true); }

/**
 * Sets the sky color. The purpose of the sky bitmap is to fill out the empty space visible at low tilt angles.<br>
 * @param color The new sky color. If the color is transparent, sky is not rendered.
 */
  public void setSkyColor(Color color) {
    OptionsModuleJNI.Options_setSkyColor(swigCPtr, this, Color.getCPtr(color), color);
  }

/**
 * Returns the background bitmap. May be null.<br>
 * @return The background bitmap.
 */
  public Bitmap getBackgroundBitmap() {
    long cPtr = OptionsModuleJNI.Options_getBackgroundBitmap(swigCPtr, this);
    return (cPtr == 0) ? null : new Bitmap(cPtr, true);
  }

/**
 * Sets the background bitmap. The purpose of the background bitmap is to fill out the empty space when there's<br>
 * no map data visible. The bitmap will get scaled and repeated to cover the hole visible area. If a null pointer is passed, <br>
 * the background won't be drawn.<br>
 * The width and height of the bitmap must be power of two (for example: 256 * 256 or 128 * 512). <br>
 * It's also preferred if the bitmap was square (width == height), but this is not a requirement. <br>
 * The default is "default_background.png".<br>
 * @param backgroundBitmap The new background bitmap.
 */
  public void setBackgroundBitmap(Bitmap backgroundBitmap) {
    OptionsModuleJNI.Options_setBackgroundBitmap(swigCPtr, this, Bitmap.getCPtr(backgroundBitmap), backgroundBitmap);
  }

/**
 * Returns the horizontal alignment of the watermark.<br>
 * @return The horizontal alignment of the watermark.
 */
  public float getWatermarkAlignmentX() {
    return OptionsModuleJNI.Options_getWatermarkAlignmentX(swigCPtr, this);
  }

/**
 * Sets the position of the watermark relative to the screen. Values will be clamped to [-1, 1] range.<br>
 * @param alignmentX The new horizontal alignment for the watermark. -1 means the left side,<br>
 * 0 the center and 1 the right side. The default is 1.
 */
  public void setWatermarkAlignmentX(float alignmentX) {
    OptionsModuleJNI.Options_setWatermarkAlignmentX(swigCPtr, this, alignmentX);
  }

/**
 * Returns the vertical alignment of the watermark.<br>
 * @return The vertical alignment of the watermark.
 */
  public float getWatermarkAlignmentY() {
    return OptionsModuleJNI.Options_getWatermarkAlignmentY(swigCPtr, this);
  }

/**
 * Sets the position of the watermark relative to the screen. Values will be clamped to [-1, 1] range.<br>
 * @param alignmentY The new vertical alignment for the watermark. -1 means the bottom,<br>
 * 0 the center and 1 the top. The default is -1.
 */
  public void setWatermarkAlignmentY(float alignmentY) {
    OptionsModuleJNI.Options_setWatermarkAlignmentY(swigCPtr, this, alignmentY);
  }

/**
 * Returns the watermark relative scale.<br>
 * @return The watermark relative scale. The default is 1.
 */
  public float getWatermarkScale() {
    return OptionsModuleJNI.Options_getWatermarkScale(swigCPtr, this);
  }

/**
 * Set the watermark relative scale. By default, watermark size is independant of the actual watermark bitmap size.<br>
 * This method can be used to change this.<br>
 * @param scale The new relative scale value.
 */
  public void setWatermarkScale(float scale) {
    OptionsModuleJNI.Options_setWatermarkScale(swigCPtr, this, scale);
  }

/**
 * Returns the watermark bitmap. May be null.<br>
 * @return The watermark bitmap.
 */
  public Bitmap getWatermarkBitmap() {
    long cPtr = OptionsModuleJNI.Options_getWatermarkBitmap(swigCPtr, this);
    return (cPtr == 0) ? null : new Bitmap(cPtr, true);
  }

/**
 * Sets the watermark bitmap. This is only available with enterprise licenses. The watermark will be displayed<br>
 * on top of the map view in a user chosen corner. If null is passed no watermark will be displayed.<br>
 * @param watermarkBitmap The new watermark bitmap.
 */
  public void setWatermarkBitmap(Bitmap watermarkBitmap) {
    OptionsModuleJNI.Options_setWatermarkBitmap(swigCPtr, this, Bitmap.getCPtr(watermarkBitmap), watermarkBitmap);
  }

/**
 * Returns the padding of the watermark.<br>
 * @return The padding of the watermark in dp.
 */
  public ScreenPos getWatermarkPadding() { return new ScreenPos(OptionsModuleJNI.Options_getWatermarkPadding(swigCPtr, this), true); }

/**
 * Sets the padding between the watermark and the edge of the screen.<br>
 * @param padding The new padding for the watermark in dp. The default is 4,4.
 */
  public void setWatermarkPadding(ScreenPos padding) {
    OptionsModuleJNI.Options_setWatermarkPadding(swigCPtr, this, ScreenPos.getCPtr(padding), padding);
  }

/**
 * Returns the state of the user input flag.<br>
 * @return True if user input is allowed.
 */
  public boolean isUserInput() {
    return OptionsModuleJNI.Options_isUserInput(swigCPtr, this);
  }

/**
 * Sets the state of the user input flag. If set to false the user won't be able to pan the map using touch controls,<br>
 * programmatic map panning using MapView methods is still possible. The default is false.<br>
 * @param enabled The new state of the user input flag.
 */
  public void setUserInput(boolean enabled) {
    OptionsModuleJNI.Options_setUserInput(swigCPtr, this, enabled);
  }

/**
 * Returns the state of the kinetic panning flag.<br>
 * @return True if kinetic panning is enabled.
 */
  public boolean isKineticPan() {
    return OptionsModuleJNI.Options_isKineticPan(swigCPtr, this);
  }

/**
 * Sets the state of the kinetic panning flag. Kinetic panning allows the map to pan automatically using<br>
 * the inertia of the last swipe, after the user has finished interacting with the touch screen.<br>
 * Default is true.<br>
 * @param enabled The new state of the kinetic panning flag.
 */
  public void setKineticPan(boolean enabled) {
    OptionsModuleJNI.Options_setKineticPan(swigCPtr, this, enabled);
  }

/**
 * Returns the state of the kinetic rotation flag.<br>
 * @return True if kinetic rotation is enabled.
 */
  public boolean isKineticRotation() {
    return OptionsModuleJNI.Options_isKineticRotation(swigCPtr, this);
  }

/**
 * Sets the state of the kinetic rotation flag. Kinetic rotation allows the map to rotate automatically using<br>
 * the inertia of the last swipe, after the user has finished interacting with the touch screen.<br>
 * Default is true.<br>
 * @param enabled The new state of the kinetic rotation flag.
 */
  public void setKineticRotation(boolean enabled) {
    OptionsModuleJNI.Options_setKineticRotation(swigCPtr, this, enabled);
  }

/**
 * Returns the state of kinetic zoom flag.<br>
 * @return True if kinetic zooming is enabled.
 */
  public boolean isKineticZoom() {
    return OptionsModuleJNI.Options_isKineticZoom(swigCPtr, this);
  }

/**
 * Sets the state of the kinetic zooming flag. Kinetic zooming allows the map to zoom automatically using<br>
 * the inertia of the last swipe, after the user has finished interacting with the touch screen.<br>
 * Default is true.<br>
 * @param enabled The new state of the kinetic zooming flag.
 */
  public void setKineticZoom(boolean enabled) {
    OptionsModuleJNI.Options_setKineticZoom(swigCPtr, this, enabled);
  }

/**
 * Returns the state of the map rotatability flag.<br>
 * @return True if map rotating is enabled.
 */
  public boolean isRotatable() {
    return OptionsModuleJNI.Options_isRotatable(swigCPtr, this);
  }

/**
 * Sets the state of the map rotatability flag. If set to false the map can't be rotated by any means. The default is true.<br>
 * @param enabled The new state of the map rotatability flag.
 */
  public void setRotatable(boolean enabled) {
    OptionsModuleJNI.Options_setRotatable(swigCPtr, this, enabled);
  }

/**
 * Returns the tilt range constraint.<br>
 * @return The tilt range constraint in degrees.
 */
  public MapRange getTiltRange() { return new MapRange(OptionsModuleJNI.Options_getTiltRange(swigCPtr, this), true); }

/**
 * Sets the tilt range constraint. This will limit the tilt angle of the camera to the specified range.<br>
 * The current tilt angle will remain unaffected, until the next time the tilt angle changes.<br>
 * The minimum tilt angle is 30 degrees and the maximum is 90 degrees. Values that are out of range will be clamped.<br>
 * The default value is MapRange(30, 90).<br>
 * @param tiltRange The new tilt range constraint in degrees.
 */
  public void setTiltRange(MapRange tiltRange) {
    OptionsModuleJNI.Options_setTiltRange(swigCPtr, this, MapRange.getCPtr(tiltRange), tiltRange);
  }

/**
 * Returns the zoom range constraint.<br>
 * @return The zoom range constraint.
 */
  public MapRange getZoomRange() { return new MapRange(OptionsModuleJNI.Options_getZoomRange(swigCPtr, this), true); }

/**
 * Sets the zoom range constraint. This will limit the zoom level of the camera to the specified range.<br>
 * The current zoom level will remain unaffected, until the next time the zoom level changes.<br>
 * The minimum zoom value is 0 and the maximum is 24. Values that are out of range will be clamped.<br>
 * The default value is MapRange(0, 24).<br>
 * @param zoomRange The new zoom range constraint.
 */
  public void setZoomRange(MapRange zoomRange) {
    OptionsModuleJNI.Options_setZoomRange(swigCPtr, this, MapRange.getCPtr(zoomRange), zoomRange);
  }

/**
 * Returns the map panning bounds constraints. Map bounds minimum and maximum points are in the base<br>
 * projection's coordinate system.<br>
 * @return The map bounds constraints.
 */
  public MapBounds getPanBounds() { return new MapBounds(OptionsModuleJNI.Options_getPanBounds(swigCPtr, this), true); }

/**
 * Sets the map panning bounds constraints. This will limit camera movement to the specified bounds.<br>
 * The current camera position will remain unaffected, until the next time camera position changes.<br>
 * Map bounds minimum and maximum points are expected to be in the base projection's coordinate system.<br>
 * If the bounds are larger than the world size, they will be clamped to world bounds. The default value covers the <br>
 * whole world.<br>
 * @param panBounds The new map bounds constraints.
 */
  public void setPanBounds(MapBounds panBounds) {
    OptionsModuleJNI.Options_setPanBounds(swigCPtr, this, MapBounds.getCPtr(panBounds), panBounds);
  }

/**
 * Returns the focus point offset (from screen center) in pixels.<br>
 * @return The focus point offset in pixels.
 */
  public ScreenPos getFocusPointOffset() { return new ScreenPos(OptionsModuleJNI.Options_getFocusPointOffset(swigCPtr, this), true); }

/**
 * Sets the focus point offset (from screen center) in pixels.<br>
 * @param offset The new focus point offset in pixels.
 */
  public void setFocusPointOffset(ScreenPos offset) {
    OptionsModuleJNI.Options_setFocusPointOffset(swigCPtr, this, ScreenPos.getCPtr(offset), offset);
  }

/**
 * Returns the base projection.<br>
 * @return The base projection.
 */
  public Projection getBaseProjection() {
  long cPtr = OptionsModuleJNI.Options_getBaseProjection(swigCPtr, this);
  if (cPtr == 0) {
    return null;
  }
  /** @hidden */
  return com.carto.projections.Projection.swigCreatePolymorphicInstance(cPtr, true);
}

/**
 * Sets the base projection. All MapView, MapEventListener and Options methods use the coordinate system of this projection.<br>
 * For example, if base projection is set to EPSG3857 then MapView::getFocusPos returns the coordinates in the EPSG3857 coordinate system,<br>
 * The same applies to setter methods like MapView::setFocusPos which expect the input coordinates to be in the base projection's coordinate system.<br>
 * The default is EPSG3857.<br>
 * @param baseProjection The new base projection.
 */
  public void setBaseProjection(Projection baseProjection) {
    OptionsModuleJNI.Options_setBaseProjection(swigCPtr, this, Projection.getCPtr(baseProjection), baseProjection);
  }

/**
 * Returns the raw pointer to the object. This is used internally by the SDK.<br>
 * @return The internal pointer of the object.
 */
  /** @hidden */
  public long swigGetRawPtr() {
    return OptionsModuleJNI.Options_swigGetRawPtr(swigCPtr, this);
  }

}
